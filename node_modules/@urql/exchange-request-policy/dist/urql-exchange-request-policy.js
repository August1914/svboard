var e = require("@urql/core");

var t = require("wonka");

function _extends() {
  return (_extends = Object.assign || function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r) {
        if (Object.prototype.hasOwnProperty.call(r, n)) {
          e[n] = r[n];
        }
      }
    }
    return e;
  }).apply(this, arguments);
}

exports.requestPolicyExchange = function requestPolicyExchange(r) {
  return function(n) {
    var o = n.forward;
    var c = new Map;
    var a = (r || {}).ttl || 3e5;
    function processIncomingOperation(t) {
      if ("query" !== t.kind || "cache-first" !== t.context.requestPolicy && "cache-only" !== t.context.requestPolicy) {
        return t;
      }
      if ((new Date).getTime() - (c.get(t.key) || 0) > a && (!r.shouldUpgrade || r.shouldUpgrade(t))) {
        return e.makeOperation(t.kind, t, _extends({}, t.context, {
          requestPolicy: "cache-and-network"
        }));
      }
      return t;
    }
    function processIncomingResults(e) {
      var t = e.operation.context.meta;
      if (!c.has(e.operation.key) || !t || "miss" === t.cacheOutcome) {
        c.set(e.operation.key, (new Date).getTime());
      }
    }
    return function(e) {
      return t.tap(processIncomingResults)(o(t.map(processIncomingOperation)(e)));
    };
  };
};
//# sourceMappingURL=urql-exchange-request-policy.js.map
