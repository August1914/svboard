{"version":3,"file":"urql-svelte.mjs","sources":["../src/internal.ts","../src/operationStore.ts","../src/context.ts","../src/operations.ts"],"sourcesContent":["export const _contextKey = '$$_urql';\nexport const _storeUpdate = new Set<object>();\nexport const _markStoreUpdate =\n  process.env.NODE_ENV !== 'production'\n    ? (value: object) => _storeUpdate.add(value)\n    : () => undefined;\n","import { Readable, writable } from 'svelte/store';\nimport { DocumentNode } from 'graphql';\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\nimport { OperationContext, CombinedError } from '@urql/core';\n\nimport { _storeUpdate } from './internal';\n\nconst emptyUpdate = Object.create(null);\n\ntype Updater<T> = (value: T) => T;\n\n/**\n * This Svelte store wraps both a `GraphQLRequest` and an `OperationResult`.\n * It can be used to update the query and read the subsequent result back.\n */\nexport interface OperationStore<Data = any, Vars = any>\n  extends Readable<OperationStore<Data, Vars>> {\n  // Input properties\n  query: DocumentNode | TypedDocumentNode<Data, Vars> | string;\n  variables: Vars | null;\n  context: Partial<OperationContext> | undefined;\n  // Output properties\n  readonly stale: boolean;\n  readonly fetching: boolean;\n  readonly data: Data | undefined;\n  readonly error: CombinedError | undefined;\n  readonly extensions: Record<string, any> | undefined;\n  // Writable properties\n  set(value: Partial<OperationStore<Data, Vars>>): void;\n  update(updater: Updater<Partial<OperationStore<Data, Vars>>>): void;\n}\n\nexport function operationStore<Data = any, Vars = object>(\n  query: string | DocumentNode | TypedDocumentNode<Data, Vars>,\n  variables?: Vars | null,\n  context?: Partial<OperationContext & { pause: boolean }>\n): OperationStore<Data, Vars> {\n  const internal = {\n    query,\n    variables: variables || null,\n    context,\n  };\n\n  const state = {\n    stale: false,\n    fetching: true,\n    data: undefined,\n    error: undefined,\n    extensions: undefined,\n  } as OperationStore<Data, Vars>;\n\n  const svelteStore = writable(state);\n  let _internalUpdate = false;\n\n  state.set = function set(value?: Partial<typeof state>) {\n    if (!value || value === state) value = emptyUpdate;\n\n    _internalUpdate = true;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!_storeUpdate.has(value!)) {\n        for (const key in value) {\n          if (!(key in internal)) {\n            throw new TypeError(\n              'It is not allowed to update result properties on an OperationStore.'\n            );\n          }\n        }\n      }\n\n      _storeUpdate.delete(value!);\n    }\n\n    for (const key in value) {\n      if (key === 'query' || key === 'variables' || key === 'context') {\n        (internal as any)[key] = value[key];\n      } else if (key === 'fetching') {\n        (state as any)[key] = !!value[key];\n      } else if (key in state) {\n        state[key] = value[key];\n      }\n    }\n\n    (state as any).stale = !!value!.stale;\n\n    _internalUpdate = false;\n    svelteStore.set(state);\n  };\n\n  state.update = function update(fn: Updater<typeof state>): void {\n    state.set(fn(state));\n  };\n\n  state.subscribe = function subscribe(run, invalidate) {\n    return svelteStore.subscribe(run, invalidate);\n  };\n\n  Object.keys(internal).forEach(prop => {\n    Object.defineProperty(state, prop, {\n      configurable: false,\n      get: () => internal[prop],\n      set(value) {\n        internal[prop] = value;\n        if (!_internalUpdate) svelteStore.set(state);\n      },\n    });\n  });\n\n  if (process.env.NODE_ENV !== 'production') {\n    const result = { ...state };\n\n    Object.keys(state).forEach(prop => {\n      Object.defineProperty(result, prop, {\n        configurable: false,\n        get() {\n          return state[prop];\n        },\n        set() {\n          throw new TypeError(\n            'It is not allowed to update result properties on an OperationStore.'\n          );\n        },\n      });\n    });\n\n    Object.keys(internal).forEach(prop => {\n      Object.defineProperty(result, prop, {\n        configurable: false,\n        get: () => internal[prop],\n        set(value) {\n          internal[prop] = value;\n          if (!_internalUpdate) svelteStore.set(state);\n        },\n      });\n    });\n\n    return result;\n  }\n\n  return state;\n}\n","import { setContext, getContext } from 'svelte';\nimport { Client, ClientOptions } from '@urql/core';\nimport { _contextKey } from './internal';\n\nexport const getClient = (): Client => getContext(_contextKey);\n\nexport const setClient = (client: Client): void => {\n  setContext(_contextKey, client);\n};\n\nexport const initClient = (args: ClientOptions): Client => {\n  const client = new Client(args);\n  setClient(client);\n  return client;\n};\n","import { onDestroy } from 'svelte';\n\nimport {\n  createRequest,\n  stringifyVariables,\n  OperationContext,\n  OperationResult,\n  GraphQLRequest,\n  TypedDocumentNode,\n} from '@urql/core';\n\nimport {\n  Source,\n  pipe,\n  map,\n  make,\n  scan,\n  concat,\n  fromValue,\n  switchMap,\n  subscribe,\n} from 'wonka';\n\nimport { OperationStore, operationStore } from './operationStore';\nimport { getClient } from './context';\nimport { _markStoreUpdate } from './internal';\nimport { DocumentNode } from 'graphql';\n\ninterface SourceRequest<Data = any, Variables = object>\n  extends GraphQLRequest<Data, Variables> {\n  context?: Partial<OperationContext> & {\n    pause?: boolean;\n  };\n}\n\nconst baseState = {\n  fetching: false,\n  stale: false,\n  error: undefined,\n  data: undefined,\n  extensions: undefined,\n};\n\nfunction toSource<Data, Variables>(store: OperationStore<Data, Variables>) {\n  return make<SourceRequest<Data, Variables>>(observer => {\n    let $request: void | GraphQLRequest<Data, Variables>;\n    let $contextKey: void | string;\n    return store.subscribe(state => {\n      const request = createRequest<Data, Variables>(\n        state.query,\n        state.variables!\n      ) as SourceRequest<Data, Variables>;\n\n      const contextKey = stringifyVariables((request.context = state.context));\n\n      if (\n        $request === undefined ||\n        request.key !== $request.key ||\n        $contextKey === undefined ||\n        contextKey !== $contextKey\n      ) {\n        $contextKey = contextKey;\n        $request = request;\n        observer.next(request);\n      }\n    });\n  });\n}\n\nexport function query<Data = any, Variables = object>(\n  store: OperationStore<Data, Variables>\n): OperationStore<Data, Variables> {\n  const client = getClient();\n  const subscription = pipe(\n    toSource(store),\n    switchMap(request => {\n      if (request.context && request.context.pause) {\n        return fromValue({ fetching: false, stale: false });\n      }\n\n      return concat([\n        fromValue({ fetching: true, stale: false }),\n        pipe(\n          client.executeQuery<Data, Variables>(request, request.context!),\n          map(result => ({\n            fetching: false,\n            ...result,\n            stale: !!result.stale,\n          }))\n        ),\n        fromValue({ fetching: false, stale: false }),\n      ]);\n    }),\n    scan(\n      (result: Partial<OperationResult<Data, Variables>>, partial) => ({\n        ...result,\n        ...partial,\n      }),\n      baseState\n    ),\n    subscribe(update => {\n      _markStoreUpdate(update);\n      store.set(update as OperationStore);\n    })\n  );\n\n  onDestroy(subscription.unsubscribe);\n  return store;\n}\n\nexport type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;\n\nexport function subscription<Data = any, Result = Data, Variables = object>(\n  store: OperationStore<Result, Variables>,\n  handler?: SubscriptionHandler<Data, Result>\n): OperationStore<Result, Variables> {\n  const client = getClient();\n  const subscription = pipe(\n    toSource(store),\n    switchMap(\n      (request): Source<Partial<OperationStore>> => {\n        if (request.context && request.context.pause) {\n          return fromValue({ fetching: false });\n        }\n\n        return concat<Partial<OperationStore>>([\n          fromValue({ fetching: true }),\n          client.executeSubscription(request, store.context),\n          fromValue({ fetching: false }),\n        ]);\n      }\n    ),\n    scan(\n      (result: Partial<OperationResult<Result, Variables>>, partial: any) => {\n        const data =\n          partial.data !== undefined\n            ? typeof handler === 'function'\n              ? handler(result.data, partial.data)\n              : partial.data\n            : result.data;\n        return { ...result, ...partial, data, stale: false };\n      },\n      baseState\n    ),\n    subscribe(update => {\n      _markStoreUpdate(update);\n      store.set(update);\n    })\n  );\n\n  onDestroy(subscription.unsubscribe);\n  return store;\n}\n\nexport type ExecuteMutation<Data = any, Variables = object> = (\n  variables?: Variables,\n  context?: Partial<OperationContext>\n) => Promise<OperationStore<Data, Variables>>;\n\ninterface GraphQLRequestInput<Data = any, Variables = object> {\n  key?: number;\n  query: DocumentNode | TypedDocumentNode<Data, Variables> | string;\n  variables?: Variables;\n}\n\nexport function mutation<Data = any, Variables = object>(\n  input: GraphQLRequestInput<Data, Variables> | OperationStore<Data, Variables>\n): ExecuteMutation<Data, Variables> {\n  const client = getClient();\n\n  const store =\n    typeof (input as any).subscribe !== 'function'\n      ? operationStore<Data, Variables>(input.query, input.variables)\n      : (input as OperationStore<Data, Variables>);\n\n  return (vars, context) => {\n    const update = {\n      fetching: true,\n      variables: vars || store.variables,\n      context: context || store.context,\n    };\n\n    _markStoreUpdate(update);\n    store.set(update);\n\n    return client\n      .mutation(store.query, store.variables as any, store.context)\n      .toPromise()\n      .then(result => {\n        const update = { fetching: false, ...result };\n        _markStoreUpdate(update);\n        store.set(update);\n        return store;\n      });\n  };\n}\n"],"names":["const","_markStoreUpdate","process","undefined","variables","query","stale","error","extensions","state","key","key$1","value","keys","set","internal","result","getClient","setClient","setContext","Client","fetching","client","toSource","store","_extends","request","subscription","partial","baseState","data","concat","context","vars"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAEOA,IAAMC,QACXC;;AAC8C;SACpCC;;;;;ACgCVH;;AAEEI,wBAAoBC;;;;IAKpBC;;;IAGAC,QAAOJ;IACPK,WAAU;;;;;EAMZC;;;;;;;iCAOcC;;;;;;;;;;aAcHC,KAAOC;UACX,iCAA6BF;UACrBA,KAAOD;aACX;;;;;;;;;;;YAcXA;;;;;SAOOI;;;MACHC;QACEC;;;eACsBH;;;;;;;;;;4BAYpBI;;QAEFF;;;;;;;;WAWGD;;;QACHC;UACEC;;;iBACsBH;;;;;;;;;SC9HnBK;;;SAEAC;EACXC,SFPyB;;;AEWzBnB,mBAAmBoB;EACnBF,EFZyB;;;;;EGoCzBG,UAAUC;EACVhB,OAAOgB;;;AAGPd;;;cAGOe;;;;;AAKHvB;;;;;;;MADF;;;;;;;;;AAuDEwB,SAAKnB;;;;;;;;;;mBAtBS;;;;aAKE;;cAEL;;MAPG,OAGJoB,aAAN;;;QAHJnB;;0BA0BKoB;;;;;;;;;AAyCN,SAfGC;UAGEC;;;;MAOJC;;uBArBaD,EAAPE;;;QAqBND;;MAhBgBR;QACZC;;;WAuBCS;;;;;eAqBPP;MAIYQ;;;;AAIVA;;;;;;iBAMWC;;;;;WAMJX;;;;;;;;;;;"}